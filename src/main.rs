// Adapted from https://github.com/esp-rs/std-training/intro/http-server

use anyhow::Result;
use core::str;
use embedded_svc::{http::Method, io::Write};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{
        delay::Delay,
        gpio::Pins,
        io::EspIOError,
        prelude::*,
        spi::{config::DriverConfig, SpiDriver, SPI2},
    },
    http::server::{Configuration, EspHttpServer},
    log::EspLogger,
    sntp::{EspSntp, SyncStatus},
    sys,
};
use esp_max31865::{Max31865, PowerFilter, Wires};
use std::{sync::mpsc, thread, time::Duration};

use wifi::wifi;

mod websocket_server;
mod wifi;

const WEBPAGE: &'static str = const_format::str_replace!(
    include_str!("../plot.html"),
    "{}",
    include_str!("../plot.js")
);

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    sys::link_patches();
    EspLogger::initialize_default();
    unsafe {
        sys::nvs_flash_init();
    }

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;
    let _wifi = wifi(
        // The constant `CONFIG` is auto-generated by `toml_config`.
        CONFIG.wifi_ssid,
        CONFIG.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    let ntp = EspSntp::new_default().unwrap();
    println!("Synchronising with NTP server");
    while ntp.get_sync_status() != SyncStatus::Completed {}
    println!("Time sync completed");

    let pins = peripherals.pins;
    let spi = peripherals.spi2;
    let (temp_sender, temp_receiver) = mpsc::channel();
    thread::spawn(|| update_temp(pins, spi, temp_sender).unwrap());

    // Set the HTTP server
    let mut http_server = EspHttpServer::new(&Configuration::default())?;
    // http://<sta ip>/temperature handler
    http_server.fn_handler(
        "/",
        Method::Get,
        move |request| -> core::result::Result<(), EspIOError> {
            let mut response = request.into_ok_response()?;
            response.write_all(WEBPAGE.as_bytes())?;
            Ok(())
        },
    )?;

    println!("Http server awaiting connection");

    let addr = "0.0.0.0:3012";
    websocket_server::send_temp_to_client(addr, temp_receiver);

    unreachable!()
}

fn update_temp(
    pins: Pins,
    spi: SPI2,
    temp_sender: mpsc::Sender<u16>,
) -> Result<(), anyhow::Error> {
    let sclk = pins.gpio6;
    let sdo = pins.gpio2;
    let sdi = pins.gpio7;
    let config = DriverConfig::new();
    let driver = SpiDriver::new(spi, sclk, sdo, Some(sdi), &config).unwrap();

    let delay = Delay::new_default();
    let cs = pins.gpio10;
    let rtd_nominal = 1000.; // if PT100: 100, if PT1000: 1000
    let ref_resistance = 431.; // ref resistor on max31865 board

    let mut temp_sensor =
        Max31865::new(&driver, &delay, cs, rtd_nominal, ref_resistance)
            .unwrap();
    temp_sensor
        .set_config(
            Some(Wires::Three),
            Some(PowerFilter::FiftyHertz),
            Some(true),  //??
            Some(true),  //??
            Some(false), //??
        )
        .unwrap();

    let mut temp_sensor = MockSensor::new();

    loop {
        let temp = temp_sensor.read_temperature_celsius().unwrap();
        let temp = (temp * 10.).round() as u16;
        temp_sender.send(temp).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
}

struct MockSensor {
    value: f32,
}

impl MockSensor {
    fn new() -> Self {
        Self { value: 0.0 }
    }
    fn read_temperature_celsius(&mut self) -> Result<f32, ()> {
        self.value += 1.0;
        Ok(self.value)
    }
}
